## 模拟

## 双指针

双指针法基本都是应用在数组，字符串与链表的题目上

双指针中很多技巧，快慢指针，滑动窗口，条件轮询指针，预先对序列排序

26. ### 删除有序数组中的重复项

https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/

### LeetCode 80 删除有序数组中的重复项 II

https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150

https://blog.csdn.net/UZDW_/article/details/133414733?spm=1001.2014.3001.5501



### LCP 28. 采购方案

https://leetcode.cn/problems/4xy4Wx/description/

https://blog.csdn.net/UZDW_/article/details/143418196

### 977.有序数组的平方

- 结构：顺序表

- 思想：蛮力法：双指针

- 问题：杂题

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        # 若所有为正数，正序平方返回，负数，逆序平方返回
        # 正负均有，找到边界，对比绝对值返回
        if len(nums) == 1:
            return [nums[0] * nums[0]]

        if nums[0] <= 0 and nums[-1] <= 0:
            res = []
            for i in range(len(nums) - 1, -1, -1):
                res.append(nums[i] * nums[i])
            return res
        elif nums[0] >= 0 and nums[-1] >= 0:
            return [n * n for n in nums]
        else:
            i = 0
            while i < len(nums):
                if nums[i] >= 0:
                    i -= 1
                    break
                i += 1
            j = i + 1

            res = []
            while i >= 0 or j < len(nums):
                if i >= 0 and j < len(nums):
                    if nums[i] * nums[i] > nums[j] * nums[j]:
                        res.append(nums[j] * nums[j])
                        j += 1
                    else:
                        res.append(nums[i] * nums[i])
                        i -= 1
                elif i >= 0:
                    res.append(nums[i] * nums[i])
                    i -= 1
                else:
                    res.append(nums[j] * nums[j])
                    j += 1
            return res
```

### 19. 删除链表的倒数第 N 个结点

https://leetcode.cn/problems/remove-nth-node-from-end-of-list/

- 结构：链表

- 思想：蛮力法： 双指针

- 问题：杂题

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy_node = ListNode(next=head)
        slow, fast = dummy_node, dummy_node
        while n > 0:
            fast = fast.next
            n -= 1
        while fast.next:
            slow = slow.next
            fast = fast.next
        delete = slow.next
        slow.next = slow.next.next
        delete.next = None
        return dummy_node.next

```

### 142. 环形链表 II

https://leetcode.cn/problems/linked-list-cycle-ii/description/

- 结构：链表

- 思想：蛮力法： 双指针（快慢指针）

- 问题：杂题

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return None

        slow, fast = head, head.next
        while fast.next != slow.next:
            if not fast.next or not fast.next.next:
                return None
            fast = fast.next.next
            slow = slow.next
        slow = head
        fast = fast.next
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
```

### 21. 合并两个有序链表

https://leetcode.cn/problems/merge-two-sorted-lists/description/

### 23. 合并 K 个升序链表

https://leetcode.cn/problems/merge-k-sorted-lists/





### 25. K 个一组翻转链表

https://leetcode.cn/problems/reverse-nodes-in-k-group/description/





[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)



## 滑动窗口

### 3. 无重复字符的最长子串

https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/



[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

## 回溯

回溯的本质是穷举

回溯数

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度就构成了树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

算法模板

```
function backtrack(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小，剪枝优化在此处考虑）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 77. 组合

```python
class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        res = []
        self._backtrack(n, k, 1, n, [], res)
        return res

    def _backtrack(self, n, k, left, right, bts, res):
        if len(bts) == k:
            res.append(bts[:])
            return
        for i in range(left, right + 1):
            bts.append(i)
            self._backtrack(n, k, i + 1, right, bts, res)
            bts.pop()

```

### 216. 组合总和 III

```python
class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        res = []
        self._backtrack(k, n, 1, 9, [], res)
        return res

    def _backtrack(self, k, n, left, right, bts, res):
        if len(bts) == k:
            if sum(bts) == n:
                res.append(bts[:])
            return
        for i in range(left, right + 1):
            bts.append(i)
            self._backtrack(k, n, i + 1, right, bts, res)
            bts.pop()

```

### 17. 电话号码的字母组合

```python
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        res = []
        self._backtrack(digits, 0, len(digits) - 1, [], res)
        return res

    def _backtrack(self, digits, left, right, bts, res):
        mapping = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }
        if len(bts) == len(digits):
            if not bts:
                return
            res.append("".join(bts))
        else:
            for i in range(left, right + 1):
                for c in mapping[digits[i]]:
                    bts.append(c)
                    self._backtrack(digits, i + 1, right, bts, res)
                    bts.pop()
```

### 39. 组合总和

```py
class Solution(object):
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        self._backtrack(candidates, 0, len(candidates) - 1, target, [], res)
        return res

    def _backtrack(self, candidates, left, right, target, bts, res):
        _sum = sum(bts)
        if _sum == target:
            res.append(bts[:])
        elif _sum > target:
            return
        else:
            for i in range(left, right + 1):
                bts.append(candidates[i])
                self._backtrack(candidates, i, right, target, bts, res)
                bts.pop()

# 使用减法更好一些
# class Solution:
#     def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
#         res_list = []
#         self.backtrack(0, candidates, target, res_list, [])
#         return res_list

#     def backtrack(self, idx, candidates, target, res_list, res):
#         if target == 0:
#             res_list.append(res.copy())
#         elif target < 0:
#             ...
#         else:
#             for i in range(idx, len(candidates)):
#                 res.append(candidates[i])
#                 self.backtrack(i, candidates, target - candidates[i], res_list, res)
#                 res.pop()
```

### 40. 组合总和 II

```python
class Solution(object):
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        mapping = Counter(candidates)
        keys = list(mapping.keys())
        res = []
        self._back_track(keys, mapping, target, 0, len(keys) - 1, [], res)
        return res

    def _back_track(self, keys, mapping, target, left, right, bts, res):
        # 使用减法更合适
        _sum = sum(bts)
        if _sum == target:
            res.append(bts[:])
        elif _sum > target:
            return
        else:
            for i in range(left, right + 1):
                for j in range(1, mapping[keys[i]] + 1):
                    for k in range(j):
                        bts.append(keys[i])
                    self._back_track(keys, mapping, target, i + 1, right, bts, res)
                    for k in range(j):
                        bts.pop()

```

## 93. 复原 IP 地址

https://leetcode.cn/problems/restore-ip-addresses/

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        if len(s) > 12:
            return []
        res = []
        self._backtrack(s, 4, 0, len(s) - 1, 0, [], res)
        return res

    def _backtrack(self, s, k, left, right, start, bts, res):
        if k == 0:
            if start != right + 1:
                return
            else:
                res.append(".".join(bts))
        for i in range(left, right + 1):
            sub_str = s[start : i + 1]
            if sub_str.startswith("0") and len(sub_str) > 1 or int(sub_str) > 255:
                continue
            bts.append(sub_str)
            self._backtrack(s, k - 1, i + 1, right, i + 1, bts, res)
            bts.pop()

```

## 78. 子集

https://leetcode.cn/problems/subsets/

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        self._backtrack(nums, len(nums), 0, len(nums) - 1, [], res)
        return res

    def _backtrack(self, nums, k, left, right, bts, res):
        if k == 0:
            res.append(bts[:])
        for i in range(left, right + 1):
            for j in [True, False]:
                # 加入子集
                if j:
                    bts.append(nums[i])
                    self._backtrack(nums, k - 1, i + 1, right, bts, res)
                    bts.pop()
                # 不加入子集
                else:
                    self._backtrack(nums, k - 1, i + 1, right, bts, res)


# 动态定义函数且使用递归可以使用默认参数[]
# class Solution:
#     def subsets(self, nums: List[int]) -> List[List[int]]:
#         # 回溯法
#         # 取或不取每个数字
#         def backtrack(start=0, path=[]):
#             # 每个节点都是一个可行解
#             res.append(path[:])

#             for i in range(start, len(nums)):
#                 # 做选择，取 nums[i]
#                 path.append(nums[i])

#                 # 递归，处理下一个数字
#                 backtrack(i + 1, path)

#                 # 撤销选择，不取 nums[i]
#                 path.pop()

#         res = []
#         backtrack()
#         return res
```

## 90. 子集 II

https://leetcode.cn/problems/subsets-ii/description/

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        mapping = Counter(nums)
        keys = list(mapping)
        res = []
        self._backtrack(mapping, keys, len(nums), 0, len(keys) - 1, [], res)
        return res

    def _backtrack(self, mapping, keys, h, left, right, bts, res):
        if h == 0:
            res.append(bts[:])
        for i in range(left, right + 1):
            for j in range(mapping[keys[i]] + 1):
                for k in range(j):
                    bts.append(keys[i])
                self._backtrack(
                    mapping, keys, h - mapping[keys[i]], i + 1, right, bts, res
                )
                for k in range(j):
                    bts.pop()

```

## 46. 全排列

https://leetcode.cn/problems/permutations/

```python
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        self._backtrack(nums, [], res)
        return res

    def _backtrack(self, nums, bts, res):
        if len(nums) == len(bts):
            res.append(bts[:])
        for num in nums:
            if num in bts:
                continue
            bts.append(num)
            self._backtrack(nums, bts, res)
            bts.pop()

```

## 47. 全排列 II

https://leetcode.cn/problems/permutations-ii/description/





### 小于n的最大数

给定一个数n如23121;给定一组数字a如[2 4 9]，求由a中元素组成的小于n的最大数, 22999

https://juejin.cn/post/7345687862531194890

## 51. N 皇后

https://leetcode.cn/problems/n-queens/description/

```python
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        res = []
        land = [["."] * n for _ in range(n)]
        self._backtrack(n, land, 0, res)
        return res

    def _backtrack(self, n, land, i, res):
        if i == n:
            res.append(["".join(l) for l in land])
        for j in range(n):
            flag = True

            for k in range(i - 1, -1, -1):
                _d = i - k
                # 上面没有Q
                if i - _d > -1 and land[i - _d][j] == "Q":
                    flag = False
                    break
                # 左上斜
                if i - _d > -1 and j - _d > -1 and land[i - _d][j - _d] == "Q":
                    flag = False
                    break
                # 右上斜
                if i - _d > -1 and j + _d < n and land[i - _d][j + _d] == "Q":
                    flag = False
                    break
            if not flag:
                continue
            else:
                land[i][j] = "Q"
                self._backtrack(n, land, i + 1, res)
                land[i][j] = "."

```

### 52. N 皇后 II

https://leetcode.cn/problems/n-queens-ii/description/?envType=study-plan-v2&envId=top-interview-150

https://blog.csdn.net/UZDW_/article/details/142528808?spm=1001.2014.3001.5501

## BFS

## 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

## 429. N 叉树的层序遍历

https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/

### 103. 二叉树的锯齿形层序遍历

https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/

## DFS

### 144. 二叉树的前序遍历

https://leetcode.cn/problems/binary-tree-preorder-traversal/description/

## 145. 二叉树的后序遍历

https://leetcode.cn/problems/binary-tree-postorder-traversal/description/

## 94. 二叉树的中序遍历

https://leetcode.cn/problems/binary-tree-inorder-traversal/description/







## 797. 所有可能的路径

https://leetcode.cn/problems/all-paths-from-source-to-target/description/

回溯

仔细理解一下，回溯与dfs还是不同的，回溯一定有一颗回溯树

递归 回溯 dfs bfs

```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        res = []
        self._dfs(graph, [0], res)
        return res

    def _dfs(self, graph, bts, res):
        n = len(graph)
        _x = bts[-1]
        if _x == n - 1:
            res.append(bts[:])
            return
        for _y in graph[_x]:
            bts.append(_y)
            self._dfs(graph, bts, res)
            bts.pop()

```





## 200. 岛屿数量

https://leetcode.cn/problems/number-of-islands

DFS

```python
class Solution:
    def _dfs(self, grid, m, n, i, j):
        if 0 <= i < m and 0 <= j < n and grid[i][j] == "1":
            grid[i][j] = "2"
            self._dfs(grid, m, n, i - 1, j)
            self._dfs(grid, m, n, i, j - 1)
            self._dfs(grid, m, n, i, j + 1)
            self._dfs(grid, m, n, i + 1, j)
            return 1
        return 0

    def numIslands(self, grid: List[List[str]]) -> int:
        res = 0
        m = len(grid)
        n = len(grid[0])
        for i in range(m):
            for j in range(n):
                res += self._dfs(grid, m, n, i, j)
        return res

```

## 695. 岛屿的最大面积

DFS

https://leetcode.cn/problems/max-area-of-island/description/

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        res = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                res = max(res, self._dfs(grid, i, j))
        return res

    def _dfs(self, grid, i, j):
        res = 0
        m, n = len(grid), len(grid[0])
        if 0 <= i < m and 0 <= j < n and grid[i][j] == 1:
            grid[i][j] = 2
            res += 1
            res += self._dfs(grid, i + 1, j)
            res += self._dfs(grid, i - 1, j)
            res += self._dfs(grid, i, j + 1)
            res += self._dfs(grid, i, j - 1)
        return res

```

## 463. 岛屿的周长

https://leetcode.cn/problems/island-perimeter/description/

```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    return self._dfs(grid, i, j)

    def is_edge(self, grid, i, j):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] != 0:
            return False
        else:
            return True

    def _dfs(self, grid, i, j):
        res = 0
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:
            grid[i][j] = 2
            for _x, _y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                if self.is_edge(grid, i + _x, j + _y):
                    res += 1
                else:
                    res += self._dfs(grid, i + _x, j + _y)
        return res

```



## 417. 太平洋大西洋水流问题

https://leetcode.cn/problems/pacific-atlantic-water-flow/description/

## 127. 单词接龙

https://leetcode.cn/problems/word-ladder/description/





## 133. 克隆图

https://leetcode.cn/problems/clone-graph/

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

from typing import Optional
class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        # bfs
        if not node:
            return node
        mapping = {id(node): Node(node.val)}
        from queue import Queue
        queue = Queue()
        queue.put(node)

        while not queue.empty():
            item = queue.get()
            new_item = mapping.get(id(item))
            for neighbor in item.neighbors:
                if id(neighbor) not in mapping:
                    new_neighbor = Node(neighbor.val)
                    mapping[id(neighbor)] = new_neighbor
                    queue.put(neighbor)
                new_item.neighbors.append(mapping[id(neighbor)])
        return mapping[id(node)]
        
```

