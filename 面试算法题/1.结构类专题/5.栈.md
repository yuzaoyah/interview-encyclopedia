



## 20. 有效的括号

- 结构：栈

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def isValid(self, s: str) -> bool:
        ht = {"(": ")", "[": "]", "{": "}"}
        stack = []
        for c in s:
            if c in ht:
                stack.append(c)
            else:
                if stack and ht[stack[-1]] == c:
                    stack.pop()
                else:
                    return False
        return not stack

```

## 1047. 删除字符串中的所有相邻重复项

https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/

- 结构：栈

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        stack = []
        for c in s:
            if stack and stack[-1] == c:
                stack.pop()
            else:
                stack.append(c)
        return "".join(stack)
```

## 150. 逆波兰表达式求值

- 结构：栈

- 思想：蛮力法： 模拟

- 问题：杂题

https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/

```python
class Solution:

    def calc(self, a, b, c):
        if c == "+":
            return a + b
        elif c == "-":
            return a - b
        elif c == "*":
            return a * b
        else:
            # 特别注意，Python 中 整除 // 为向下截断 6 // -10 == -1，如果要向0截断，使用 int(a / b) 或者 math.trunc(a / b)
            return int(a / b)

    def evalRPN(self, tokens: List[str]) -> int:
        calc = set(["+", "-", "*", "/"])
        stack = []
        for token in tokens:
            if token not in calc:
                stack.append(token)
            else:
                a, b = stack.pop(), stack.pop()
                print(b, a, token)
                stack.append(self.calc(int(b), int(a), token))  # 注意操作数顺序
        return int(stack[-1])

```







## 239. 滑动窗口最大值

- 结构：栈:单调栈

- 思想：蛮力法： 模拟

- 问题：杂题

https://leetcode.cn/problems/sliding-window-maximum/description/

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # 由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 i 和 j，其中 i 在 j 的左侧（i<j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]），那么会发生什么呢？

# 当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中，这是 i 在 j 的左侧所保证的。因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将 nums[i] 永久地移除。

        q = deque()
        for i in range(k):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)

        res = [nums[q[0]]]
        for i in range(k, len(nums)):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            while q[0] <= i - k:
                q.popleft()
            res.append(nums[q[0]])
        return res

```





## 739. 每日温度

- 结构：栈:单调栈

- 思想：蛮力法： 模拟

- 问题：杂题

https://leetcode.cn/problems/daily-temperatures/description/

```python
class Solution(object):
    def dailyTemperatures(self, temperatures):
        """
        :type temperatures: List[int]
        :rtype: List[int]
        """
        res = [0] * len(temperatures)
        stack = [0]
        for i in range(1, len(temperatures)):
            if temperatures[i] < temperatures[stack[-1]]:
                stack.append(i)
            else:
                while stack and temperatures[stack[-1]] < temperatures[i]:
                    item = stack.pop()
                    res[item] = i - item
                stack.append(i)
        return res

```





## 496. 下一个更大元素 I

- 结构：栈:单调栈

- 思想：蛮力法： 模拟

- 问题：杂题

https://leetcode.cn/problems/next-greater-element-i/description/

```python
class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        ht = {num: -1 for num in nums1}
        # 单调递增栈
        stack = [0]
        for i in range(1, len(nums2)):
            if nums2[i] < nums2[stack[-1]]:
                stack.append(i)
            else:
                while stack and nums2[stack[-1]] < nums2[i]:
                    item = stack.pop()
                    if nums2[item] in ht:
                        ht[nums2[item]] = nums2[i]
                stack.append(i)
        res = [-1] * len(nums1)
        for i in range(len(nums1)):
            res[i] = ht[nums1[i]]
        return res

```

## 503. 下一个更大元素 II

- 结构：栈:单调栈

- 思想：蛮力法： 模拟

- 问题：杂题

https://leetcode.cn/problems/next-greater-element-ii/

```python
class Solution(object):
    def nextGreaterElements(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        length = len(nums)
        res = [-1] * length
        stack = [0]
        for i in range(1, length * 2):
            idx = i % length
            if nums[idx] <= nums[stack[-1]]:
                stack.append(idx)
            else:
                while stack and nums[idx] > nums[stack[-1]]:
                    item = stack.pop()
                    res[item] = nums[idx]
                stack.append(idx)
        return res

```

## 42. 接雨水

- 结构：栈:单调栈

- 思想：蛮力法： 模拟

- 问题：杂题

https://leetcode.cn/problems/trapping-rain-water/description/

```python
class Solution(object):
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        length = len(height)

        res = 0
        stack = [0]
        for i in range(1, length):
            if height[i] <= height[stack[-1]]:
                stack.append(i)
            else:
                while stack and height[i] > height[stack[-1]]:
                    item = stack.pop()
                    if not stack:
                        continue
                    left = stack[-1]

                    res += (min(height[i], height[left]) - height[item]) * (
                        i - left - 1
                    )
                stack.append(i)
        return res

```

