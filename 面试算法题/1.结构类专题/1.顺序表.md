### 反转字符串数组

- 题源：[LeetCode 344 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

- 难度：E

- 结构：顺序表

- 思想：蛮力法

- 问题：杂题

```python
class Solution(object):
    def reverseString(self, s):
        """
        :type s: List[str]
        :rtype: None Do not return anything, modify s in-place instead.
        """
        length = len(s)
        for i in range(length // 2):
            s[i], s[length - 1 - i] = s[length - 1 - i], s[i]
```

### 移除元素

- 题源：[LeetCode 27 移除元素](https://leetcode.cn/problems/remove-element/description/)

- 难度：E

- 结构：顺序表

- 思想：蛮力法：双指针

- 问题：杂题

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if not nums:
            return 0
        left, right = 0, len(nums) - 1
        if left == right:
            return left - (nums[left] == val) + 1
        while left < right:
            if nums[left] !=val:
                left += 1
            elif nums[right] == val:
                right -= 1
            else:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        return left - (nums[left] == val) + 1
```

### 长度最小的子数组

- 题源：[LeetCode 209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

- 难度：M

- 结构：顺序表

- 思想：蛮力法：滑动窗口

- 问题：杂题

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        l = len(nums) + 1
        sumary = nums[0]
        left = right = 0
        while -1 < left <= right < len(nums):
            if sumary >= target:
                l = min(l, right - left + 1)
                left += 1
                if left <= right:
                    sumary -= nums[left - 1]
                else:
                    break
            else:
                right += 1
                if right < len(nums):
                    sumary += nums[right]
                else:
                    break
        if l > len(nums):
            return 0
        else:
            return l
```

### 区间和

- 题源：https://kamacoder.com/problempage.php?pid=1070

- 难度：

- 结构：顺序表

- 思想：蛮力法：前缀和

- 问题：杂题

```python
n = 0
nums = []
questions = []

try:
    n = int(input())
    for _ in range(n):
        nums.append(int(input()))
    while True:
        r = input().split(" ")
        questions.append((int(r[0]), int(r[1])))

except EOFError:
    pass

prefix_sum = [0] * len(nums)
for i in range(1, len(nums)):
    prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]

for a, b in questions:
    print(prefix_sum[b] - prefix_sum[a] + nums[b])
```

### 开发商购买土地

- 题源：https://kamacoder.com/problempage.php?pid=1044

- 难度：

- 结构：顺序表

- 思想：蛮力法：前缀和

- 问题：杂题

### 和为 K 的子数组

- 题源：[LeetCode 560 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

- 难度：M



### 螺旋矩阵

- 题源：[LeetCode 54 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/)
- 难度：M
- 结构：顺序表
- 思想：蛮力法：模拟
- 问题：杂题

特别注意矩形情况最内圈的边界条件

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        m, n = len(matrix), len(matrix[0])
        c = min(math.ceil(m / 2), math.ceil(n / 2))
        for i in range(c):
            x, y = i, i - 1

            y += 1
            if not (y < n - i):
                return res
            while y < n - i:
                res.append(matrix[x][y])
                y += 1
            y -= 1

            x += 1
            if not (x < m - i):
                return res
            while x < m - i:
                res.append(matrix[x][y])
                x += 1
            x -= 1

            y -= 1
            if not (y > i - 1):
                return res
            while y > i - 1:
                res.append(matrix[x][y])
                y -= 1
            y += 1

            x -= 1
            if not (x > i):
                return res
            while x > i:
                res.append(matrix[x][y])
                x -= 1
        return res
```

