```
class TreeNode:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right
```





## 226. 翻转二叉树

https://leetcode.cn/problems/invert-binary-tree/description/

- 结构：树-二叉树

- 思想：蛮力法： 模拟

- 问题：杂题

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """
        if not root:
            return root
        root.left, root.right = root.right, root.left
        if root.left:
            self.invertTree(root.left)
        if root.right:
            self.invertTree(root.right)
        return root
```

## 104. 二叉树的最大深度

https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
        
```

## 111. 二叉树的最小深度

https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minDepth(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        res = sys.maxsize
        if root.left:
            res = min(res, self.minDepth(root.left))
        if root.right:
            res = min(res, self.minDepth(root.right))
        return res + 1

```

## 222. 完全二叉树的节点个数

https://leetcode.cn/problems/count-complete-tree-nodes/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.right) + self.countNodes(root.left)
```







## 110. 平衡二叉树

https://leetcode.cn/problems/balanced-binary-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        return self._isBalancedAndHight(root)[0]

    def _isBalancedAndHight(self, root):
        if not root:
            return True, 0
        left_flag, left_height = self._isBalancedAndHight(root.left)
        right_flag, right_height = self._isBalancedAndHight(root.right)
        return left_flag and right_flag and abs(
            left_height - right_height
        ) < 2, 1 + max(left_height, right_height)

```





## 257. 二叉树的所有路径

https://leetcode.cn/problems/binary-tree-paths/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        mapping = {root: str(root.val)}
        stack = deque([root])
        while stack:
            item = stack.pop()
            if not item.right and not item.left:
                res.append(mapping[item])
            if item.right:
                stack.append(item.right)
                mapping[item.right] = mapping[item] + "->" + str(item.right.val)
            if item.left:
                stack.append(item.left)
                mapping[item.left] = mapping[item] + "->" + str(item.left.val)
        return res

```





## 404. 左叶子之和

https://leetcode.cn/problems/sum-of-left-leaves/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        res = 0
        if root.left and not root.left.left and not root.left.right:
            res = root.left.val
        return res + self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)

```





## 513. 找树左下角的值

https://leetcode.cn/problems/find-bottom-left-tree-value/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        prev, curr, res = 1, 0, root.val
        q = deque([root])
        while q:
            item = q.popleft()
            prev -= 1
            if item.left:
                q.append(item.left)
                curr += 1
            if item.right:
                q.append(item.right)
                curr += 1
            if prev == 0 and q:
                res = q[0].val
                prev, curr = curr, prev
        return res


# class Solution:
#     def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
#         q = deque([root])
#         while q:
#             node = q.popleft()
#             if node.right:
#                 q.append(node.right)
#             if node.left:
#                 q.append(node.left)
#             ans = node.val
#         return ans

```





## 112. 路径总和

https://leetcode.cn/problems/path-sum/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        if not root.right and not root.left:
            return targetSum == root.val
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(
            root.right, targetSum - root.val
        )

```

### 124. 二叉树中的最大路径和

https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/

## 106. 从中序与后序遍历序列构造二叉树

https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # [[左子树中序遍历序列], 根节点, [右子树中序遍历序列]]
        # [[左子树后序遍历序列], [右子树后序遍历序列], 根节点]
        if not postorder:
            return None
        index = inorder.index(postorder[-1])
        return TreeNode(
            val=postorder[-1],
            left=self.buildTree(inorder[:index], postorder[:index]),
            right=self.buildTree(inorder[index + 1 :], postorder[index:-1]),
        )

```



## 654. 最大二叉树

https://leetcode.cn/problems/maximum-binary-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        return self._constructMaximumBinaryTree(nums, 0, len(nums) - 1)
        idx = nums.index(max(nums))
        return TreeNode(nums[idx], 
            self._constructMaximumBinaryTree(nums, 0, idx - 1),
            self._constructMaximumBinaryTree(nums, idx + 1, len(nums) - 1)
        )


    def _constructMaximumBinaryTree(self, nums: List[int], left, right) -> Optional[TreeNode]:
        if left > right:
            return None
        elif left == right:
            return TreeNode(nums[left])
        else:
            max_val_idx = right
            for idx in range(left, right):
                if nums[idx] > nums[max_val_idx]:
                    max_val_idx = idx

            return TreeNode(nums[max_val_idx], 
                self._constructMaximumBinaryTree(nums, left, max_val_idx - 1),
                self._constructMaximumBinaryTree(nums, max_val_idx + 1, right)
            )
        
```



## 617. 合并二叉树

https://leetcode.cn/problems/merge-two-binary-trees/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(
        self, root1: Optional[TreeNode], root2: Optional[TreeNode]
    ) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        elif root1 and not root2:
            return root1
        elif not root1 and root2:
            return root2
        else:
            return TreeNode(
                root1.val + root2.val,
                self.mergeTrees(root1.left, root2.left),
                self.mergeTrees(root1.right, root2.right),
            )

```





## 700. 二叉搜索树中的搜索

https://leetcode.cn/problems/search-in-a-binary-search-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        tmp = root
        while tmp and tmp.val != val:
            if val < tmp.val:
                tmp = tmp.left
            else:
                tmp = tmp.right
        return tmp

```



## 501. 二叉搜索树中的众数

https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        stack = deque()
        curr = root
        count, vals = 0, []
        val, val_count = sys.maxsize, 0
        while stack or curr:
            if curr:
                stack.append(curr)
                curr = curr.left
            else:
                item = stack.pop()
                if item.val == val:
                    val_count += 1
                else:
                    if val_count > count:
                        count = val_count
                        vals = [val]
                    elif val_count == count != 0:
                        vals.append(val)
                    val, val_count = item.val, 1
                curr = item.right
        # 需要理清关系
        if val_count > count:
            return [val]
        elif val_count == count:
            return vals + [val]
        else:
            vals
        return vals

```

## 236. 二叉树的最近公共祖先

https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def lowestCommonAncestor(
        self, root: "TreeNode", p: "TreeNode", q: "TreeNode"
    ) -> "TreeNode":
        node, b1, b2 = self._lowestCommonAncestor(root, p, q)
        return node

    def _lowestCommonAncestor(
        self, root: "TreeNode", p: "TreeNode", q: "TreeNode"
    ) -> ("TreeNode", bool, bool):
        if not root:
            return None, False, False
        curr_p_flag, curr_q_flag = root.val == p.val, root.val == q.val
        curr_node = None
        if curr_p_flag or curr_q_flag:
            curr_node = root

        node1, p_flag1, q_flag1 = self._lowestCommonAncestor(root.left, p, q)
        if p_flag1 and q_flag1:
            return node1, True, True
        node2, p_flag2, q_flag2 = self._lowestCommonAncestor(root.right, p, q)
        if p_flag2 and q_flag2:
            return node2, True, True
        if (p_flag1 or p_flag2) and (q_flag1 or q_flag2):
            return root, True, True
        return (
            curr_node or node1 or node2,
            curr_p_flag or p_flag1 or p_flag2,
            curr_q_flag or q_flag1 or q_flag2,
        )


# class Solution:
#     def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
#         _, node = self._lowestCommonAncestor(root, p, q)
#         return node
#     def _lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> (int, 'TreeNode'):
#         res = 0
#         if not root:
#             return res, None
#         if root == p:
#             res |= 1
#         if root == q:
#             res |= 2
#         right_res, right_node = self._lowestCommonAncestor(root.right, p, q)
#         left_res, left_node = self._lowestCommonAncestor(root.left, p, q)
#         res |= right_res
#         res |= left_res
#         if right_res == 3:
#             return res, right_node
#         elif left_res == 3:
#             return res, left_node
#         elif res == 3:
#             return res, root
#         else:
#             return res, None

```

## 701. 二叉搜索树中的插入操作

https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)
        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        if val > root.val:
            root.right = self.insertIntoBST(root.right, val)
        return root

```

## 450. 删除二叉搜索树中的节点

https://leetcode.cn/problems/delete-node-in-a-bst/description/



## 108. 将有序数组转换为二叉搜索树

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        return self._sortedArrayToBST(nums, 0, len(nums) - 1)

    def _sortedArrayToBST(self, nums: List[int], m: int, n: int) -> Optional[TreeNode]:
        if m > n:
            return None
        idx = (m + n) >> 1
        node = TreeNode(nums[idx])
        node.left = self._sortedArrayToBST(nums, m, idx - 1)
        node.right = self._sortedArrayToBST(nums, idx + 1, n)
        return node

```



[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

[230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)



# 并查集

## 1971. 寻找图中是否存在路径

```
class UnionFInd:
    def __init__(self, items):
        self.parent = {}
        for item in items:
            self.parent[item] = item

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def join(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            self.parent[root_x] = self.parent[root_y]

    def is_same(self, x, y):
        return self.find(x) == self.find(y)


class Solution:
    def validPath(
        self, n: int, edges: List[List[int]], source: int, destination: int
    ) -> bool:
        uf = UnionFInd(range(n))
        for x, y in edges:
            uf.join(x, y)
        return uf.is_same(source, destination)

```

## 684. 冗余连接

```
class UnionFind:
    def __init__(self, items):
        self.parent = {}
        for item in items:
            self.parent[item] = item

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x == root_y:
            return
        self.parent[root_x] = root_y

    def is_same(self, x, y):
        return self.find(x) == self.find(y)


class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        uf = UnionFind(range(1, len(edges) + 1))
        for idx in range(len(edges)):
            x, y = edges[idx]
            if uf.is_same(x, y):
                return edges[idx]
            else:
                uf.union(x, y)

```

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)
