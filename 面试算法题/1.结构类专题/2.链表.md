### 移除链表元素

- 题源：[LeetCode 203 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

- 难度：E

- 结构：链表

- 思想：蛮力法-模拟

- 问题：杂题

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummy_head = ListNode(0, head)
        tmp = dummy_head
        while tmp.next:
            if tmp.next.val != val:
                tmp = tmp.next
            else:
                next_next = tmp.next.next
                tmp.next.next = None  # 去掉引用避免内存泄露
                tmp.next = next_next
        return dummy_head.next

```

### 删除排序链表中的重复元素

- 题源：[LeetCode 83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)
- 难度：E

### 反转链表

- 题源：[LeetCode 206 反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
- 难度：E
- 结构：链表

- 思想：蛮力法-模拟

- 问题：杂题

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        pre, cur = None, head
        while cur.next:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        cur.next = pre
        return cur
```

### 两数相加

- 题源：[LeetCode 2 两数相加](https://leetcode.cn/problems/add-two-numbers/)
- 难度：M

### 两两交换链表中的节点

- 题源：[LeetCode 24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

- 难度：M

- 结构：链表

- 思想：蛮力法-模拟

- 问题：杂题

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy_node = ListNode(next=head)
        pre = dummy_node
        while True:
            if not pre.next or not pre.next.next:
                return dummy_node.next
            n1, n2 = pre.next, pre.next.next
            pre.next = n2
            tail = n2.next
            n2.next = n1
            n1.next = tail
            pre = n1
```

### 旋转链表

- 题源：[LeetCode 61 旋转链表](https://leetcode.cn/problems/rotate-list/)
- 难度：M

### 重排链表

- 题源：[LeetCode 143 重排链表](https://leetcode.cn/problems/reorder-list/)
- 难度：M

### 链表相交

- 题源：[LeetCode 160 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)

- 难度：E

- 结构：链表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:

    def calc_length(self, head: ListNode):
        length = 0
        while head.next:
            length += 1
            head = head.next
        return length

    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None

        dummy_node_a = ListNode(next=headA)
        dummy_node_b = ListNode(next=headB)

        length_a = self.calc_length(dummy_node_a)
        length_b = self.calc_length(dummy_node_b)
        pa, pb = headA, headB
        if length_a > length_b:
            t = length_a - length_b
            while t:
                pa = pa.next
                t -= 1
        elif length_b > length_a:
            t = length_b - length_a
            while t:
                pb = pb.next
                t -= 1

        while pa and pb:
            if pa == pb:
                return pa
            pa = pa.next
            pb = pb.next
        return None

```

