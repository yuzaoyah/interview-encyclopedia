python 中的哈希表可以使用 dict 或者 Counter



### 有效的字母异位词

- 题源：[LeetCode 242 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

- 难度：E

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)

```

### 字母异位词分组

- 题源：[LeetCode 49 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
- 难度：M



### 查找共用字符

- 题源：[LeetCode 1002 查找共用字符](https://leetcode.cn/problems/find-common-characters/)

- 难度：E

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        ht = dict(Counter(words[0]))
        for word in words:
            counter = Counter(word)
            for k, v in ht.items():
                ht[k] = min(counter.get(k, 0), ht[k])
        res = []
        for k, v in ht.items():
            if v > 0:
                res.extend([k] * v)
        return res

# from collections import Counter

# class Solution:
#     def commonChars(self, A: List[str]) -> List[str]:
#         res = Counter(A[0])
#         for a in A[1:]:
#             res &= Counter(a)
#         return list(res.elements())
```

### 两个数组的交集

- 题源：[LeetCode 349 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

- 难度：E

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))
```

### 快乐数

- 题源：[LeetCode 202 快乐数](https://leetcode.cn/problems/happy-number/)

- 难度：E

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        ht = set()
        s = str(n)
        while True:
            _s = sum([int(c) * int(c) for c in s])
            if _s == 1:
                return True
            if _s in ht:
                return False
            ht.add(_s)
            s = str(_s)

```

### 两数之和

- 题源：[LeetCode 1 两数之和](https://leetcode.cn/problems/two-sum/)

- 难度：E

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        ht = defaultdict(list)
        for i in range(len(nums)):
            ht[nums[i]].append(i)

        for a in ht:
            b = target - a
            if b in ht:
                if a == b and len(ht[a]) < 2:
                    continue
                return [ht[a][0], ht[b][-1]]
```

### 四数相加 II

- 题源：[LeetCode 454 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

- 难度：M

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def fourSumCount(
        self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]
    ) -> int:
        c1, c2, c3, c4 = Counter(nums1), Counter(nums2), Counter(nums3), Counter(nums4)

        c12 = defaultdict(int)
        for i in c1:
            for j in c2:
                c12[i + j] += c1[i] * c2[j]
        c34 = defaultdict(int)
        for k in c3:
            for l in c4:
                c34[k + l] += c3[k] * c4[l]

        count = 0
        for n in c12:
            if -n in c34:
                count += c12[n] * c34[-n]
        return count

```

### 赎金信

- 题源：[LeetCode 383 赎金信](https://leetcode.cn/problems/ransom-note/)

- 难度：E

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        return not bool(Counter(ransomNote) - Counter(magazine))
```

### 三数之和

- 题源：[LeetCode 15 三数之和](https://leetcode.cn/problems/3sum/)

- 难度：M

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
# class Solution:
#     def threeSum(self, nums: List[int]) -> List[List[int]]:
#         counter = Counter(nums)
#         keys = list(counter)
#         keys.sort()
#         order_ht = {keys[i]: i for i in range(len(keys))}

#         res = []
#         for i in range(len(keys)):
#             counter[keys[i]] -= 1
#             for j in range(i, len(keys)):
#                 counter[keys[j]] -= 1
#                 if counter[keys[j]] < 0:
#                     counter[keys[j]] += 1
#                     continue
#                 if -(keys[i] + keys[j]) not in counter or counter[-(keys[i] + keys[j])] < 1:
#                     counter[keys[j]] += 1
#                     continue
#                 k = order_ht[-(keys[i] + keys[j])]
#                 if k < j:
#                     counter[keys[j]] += 1
#                     continue
#                 res.append([keys[i], keys[j], keys[k]])
#                 counter[keys[j]] += 1
#             counter[keys[i]] += 1
#         return res


class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        counter = Counter(nums)
        keys = list(counter)
        keys.sort()

        res = []
        for i in range(len(keys)):
            counter[keys[i]] -= 1
            for j in range(i, len(keys)):
                if counter[keys[j]] < 1:
                    counter[keys[j]] += 1
                    continue
                counter[keys[j]] -= 1
                need_num = -(keys[i] + keys[j])
                if need_num not in counter or counter[need_num] < 1 or keys[j] > need_num:
                    counter[keys[j]] += 1
                    continue
                res.append([keys[i], keys[j], need_num])
                counter[keys[j]] += 1
            counter[keys[i]] += 1
        return res

```

### 四数之和

- 题源：[LeetCode 18 四数之和](https://leetcode.cn/problems/4sum/)

- 难度：M

- 结构：哈希表

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        counter = Counter(nums)
        keys = list(counter)
        keys.sort()
        ht = defaultdict(list)
        for i in range(len(keys)):
            counter[keys[i]] -= 1
            for j in range(i, len(keys)):
                if counter[keys[j]] > 0:
                    ht[keys[i] + keys[j]].append((keys[i], keys[j]))
            counter[keys[i]] += 1

        res = []
        for a in ht:
            b = target - a
            if a not in ht or b not in ht:
                continue
            #  if not ht[a] or not ht[b]:
            #     continue
            # RuntimeError: dictionary changed size during iteration
            for x1, y1 in ht[a]:
                for x2, y2 in ht[b]:
                    if y1 <= x2:
                        counter[x1] -= 1
                        counter[y1] -= 1
                        counter[x2] -= 1
                        counter[y2] -= 1
                        if counter[x2] > -1 and counter[y2] > -1:
                            res.append([x1, y1, x2, y2])
                        counter[x1] += 1
                        counter[y1] += 1
                        counter[x2] += 1
                        counter[y2] += 1
        return res
```

### 有效的数独

- 题源：[LeetCode 36 有效的数独](https://leetcode.cn/problems/valid-sudoku/)
- 难度：M
