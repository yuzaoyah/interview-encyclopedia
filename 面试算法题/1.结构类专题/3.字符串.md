### 分段反转字符串

- 题源：[LeetCode 541 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)
- 难度：E

- 结构：字符串

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution(object):
    def reverseStr(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        new_str = []
        length, flag  = len(s), False
        for i in range(0, length, k):
            flag = not flag
            sub_right = min(i+k, length)
            if not flag:
                for j in range(i, sub_right):
                    new_str.append(s[j])
            else:
                for j in range(sub_right - 1, i - 1, -1):
                    new_str.append(s[j])
        return "".join(new_str)
```

### 替换数字

- 题源：https://kamacoder.com/problempage.php?pid=1064
- 难度：

- 结构：字符串

- 思想：蛮力法： 模拟

- 问题：杂题





### 反转字符串中的单词

- 题源：[LeetCode 151 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

- 难度：M

- 结构：字符串

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        words = []
        length = len(s)
        i = 0

        start, end = -1, -1
        while i < length:
            if start == -1:
                if s[i] != " ":
                    start = i
            if s[i] != " ":
                end = i
            if start != -1 and end != -1:
                if end < length - 1 and s[end + 1] == " ":
                    words.append(s[start:end + 1])
                    start = end = -1
                elif end >= length - 1:
                    words.append(s[start:])
                    start = end = -1
            i += 1
        print(words)
        return " ".join(reversed(words))

```

### 右旋字符串

- 题源：https://kamacoder.com/problempage.php?pid=1065

- 难度：

- 结构：字符串

- 思想：蛮力法： 模拟

- 问题：杂题



### 重复的子字符串

- 题源：[LeetCode 459 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

- 难度：E

- 结构：字符串

- 思想：蛮力法： 模拟

- 问题：杂题

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        length = len(s)
        for i in range(length // 2):
            if length // (i + 1) != length / (i + 1):
                continue
            flag = True
            for j in range(i + 1, length - 1 + 1, i + 1):
                for k in range(i + 1):
                    if s[j + k] != s[k]:
                        flag = False
                        break
                if not flag:
                    break
            if flag:
                return True
        return False

```

