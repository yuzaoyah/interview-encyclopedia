> https://www.cnblogs.com/crazymakercircle/p/17971095



接口幂等性相关问题

> 问题1：你们项目，怎么做幂等设计的？
>
> 问题2：接口的幂等性，怎么设计？
>
> 问题3：业务订单的幂等性，怎么设计？
>
> 问题4：付款请求的幂等性，怎么设计？
>
> 问题4：前端重复提交选中的数据，后台只产生一次有效操作，怎么设计？

TLDR：一锁二判三更新



## 什么是幂等性

所谓幂等性，就是一次操作和多次操作同一个资源，所产生的影响均与一次操作的影响相同。

## 为什么需要保证幂等性

实际上场景就是下单时系统卡顿重复点击多次时需要保证只能创建一笔订单，扣减库存只能被扣减一次，付款时只能成功扣款一次。否则就会出现重复订单、库存超卖、重复扣款。

## 什么原因导致幂等性问题

1. 网络层面：网络拥塞导致调用方迟迟没有获取到响应，调用方启用重试机制的情况下有可能会导致幂等性问题。服务中接口层面通常有超时重试机制，消息队列也有超时重试机制。
2. 用户层面：由于客户端APP卡顿或者网络拥塞导致页面不跳转，用户可能会重复点击导致幂等性问题。

## 单数据CRUD操作幂等性解决方案

通常整个链路仅仅调用一个服务中的一个接口，不会再发起远程调用。

增

- 有业务性唯一索引约束的，天然具有幂等性。例如，向库里插入mac地址和机器信息，mac地址列建唯一索引
- <font color="red">无业务性唯一索引约束的，不具有幂等性。例如，以分布式ID作为主键。</font>

改

- <font color="red">基于主键的计算式更新，不具备幂等性，`UPDATE goods SET number=number-1 WHERE id=1`</font>
- 基于主键的非计算式更新，具备幂等性，`UPDATE goods SET number=newNumber WHERE id=1`
- <font color="red">基于条件查询的更新，不一定具备幂等性，需要根据实际情况进行分析判断</font>

查

天然具备幂等性

删

- 基于主键的物理删除，具备幂等性
- <font color="red">基于条件的物理删除，不一定具备幂等性，需要根据实际情况进行分析判断</font>
- 基于主键的逻辑删除，具备幂等性（本质上属于基于主键的非计算式更新）
- <font color="red">基于条件的逻辑删除，不一定具备幂等性，需要根据实际情况进行分析判断（本质上属于基于条件查询的更新）</font>

上述中仅有部分场景需要做额外幂等性处理，其中又可以分为三类：

1. 无业务性唯一索引约束的新增
2. 基于主键的计算式更新
3. 基于条件的更新、删除（逻辑和物理）

后面将对这三类场景做额外幂等性处理。

## 多数据CRUD操作幂等性解决方案

- 多数据同步操作，一般是服务端提供一个统一的同步操作api，客户端调用该api完成，直接获得操作结果。
- 多数据异步操作，由于同步操作性能低，在高并发场景都会同步变异步，于是乎，服务端还要额外提供一个查询操作结果的api，去查询结果。第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。

高并发场景下的下单->支付场景，整个流程分为下单和支付两个链路，那么下单和支付都需要防止重复操作，既然是两个链路，那么两个链路分别防止重复操作就行了。这样可以转换为单数据CRUD操作。



## 幂等性问题解决方案

保证幂等性的核心思路就是保证一个资源只会被操作一次。有如下方案：

1. 全局唯一iD：**根据业务的操作和内容生成一个全局ID**，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。

   一般情况下，对分布式的全局唯一id，可以参考以下几种方式：

   - UUID
   - Snowflake
   - 数据库自增ID
   - 业务本身的唯一约束
   - 业务字段+时间戳拼接
   - **唯一索引(去重表)**

   这种方法适用于在业务中有唯一标识的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以**订单ID可以作为唯一标识**。

   这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据写入去重表，放在一个事务中，**如果重复创建，数据库会抛出唯一约束异常**，操作就会回滚。

2. token

   进入页面就向后端申请一个token存入redis等，随后检查token是否被消耗，若消耗表示已经请求过，若没有则执行请求。

3. 多版本控制

   这种方法适合在更新的场景中，比如我们要更新商品的名字，这时我们就可以在更新的接口中增加一个版本号，来做幂等：

   ```
   boolean updateGoodsName(int id,String newName,int version);
   update goods set name=#{newName},version=#{version} where id=#{id} and version<${version}
   ```

4. 状态机控制

   这种方法适合在有状态机流转的情况下，比如就会订单的创建和付款，订单的付款肯定是在之前，这时我们可以通过在设计状态字段时，使用int类型，并且通过值类型的大小来做幂等，比如订单的创建为0，付款成功为100，付款失败为99。

   在做状态机更新时，我们就可以这样控制：

   `update goods_order set status=#{status} where id=#{id} and status<#{status}`

全局唯一ID时一种通用解决方案，多版本控制比较适用于更新场景，状态机控制适用于无环的状态机。

## 接口幂等性保证整体流程

### 第一步：先加锁

高并发场景，建议是redis分布式锁，而不是低性能的DB锁，也不是CP型的 Zookeeper锁。

如果普通的redis分布式锁性能太低，该如何？

还可以考虑引入 锁的分段机制， 比如内部分成100端，总体上，就大概能线性提升 100倍。

### 第二步：进行幂等性判断

幂等性判断，就是 进行 数据检查。

可以基于状态机、流水表、唯一性索引等等前面介绍的 基础方案，进行重复操作的判断。

### 第三步：数据更新

如果通过了第二步的幂等性判断， 说明之前没有执行过更新操作。

那么就进入第三步，进行数据的更新，将数据进行持久化。

操作完成之后， 记得释放锁， 结束整个流程。

以更新订单状态为例，采用多版本控制方案

第一步，对订单加分布式锁

第二部，判断之前是否已经更新

第三步，更新，并释放锁